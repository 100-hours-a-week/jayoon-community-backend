server {
	listen 80;

    # $로 불러오는 것들은 nginx의 변수입니다. 즉, HTTP 레벨에서 알기 위해선 직접 Header 등에 작성해야 합니다.
    # 아래 추가된 헤더 변경들을 챙겨서 목적지 서버로 요청을 보냅니다.
	location / {
		# proxy_pass http://13.209.7.159:8080;
		# proxy_pass http://localhost:8080; # WAS와 nginx는 서로 다른 컨테이너라서 localhost로 접근 불가
		# proxy_pass 172.18.0.2:8080; # docker network의 사설IP
		proxy_pass http://express-app:8080 # docker network는 내부적으로 DNS 역할도 해서 컨테이너의 이름으로도 접근 가능합니다.

		# Host 헤더를 실제 클라이언트가 접근한 호스트 명으로 작성합니다.
		# 하나의 IP 주소로 여러 도메인을 서비스 한다면 이것이 꼭 필요합니다.
		# 이게 없다면 기본적으로 nginx는 proxy_pass에 표시 되어 있는 것을 Host에 추가합니다.
		# proxy_pass가 사설 IP라면 이대로 클라이언트에게 응답이 가서 이후 처리가 안 될 수도 있습니다.
		# 포트 뿐 아니라 Host를 작성한 server_name으로도 분기 가능합니다.
		proxy_set_header Host $host;

        # nginx가 아닌 바로 직전 노드의 IP를 작성합니다.
		# 요청 IP를 nginx 자신이 아닌 실제로 보낸 클라이언트의 IP로 변경합니다.
		# 만약 클라이언트와 nginx 사이에 다른 프록시(CDN, AWS ELB 등)이 있었다면 해당 프록시의 IP가 여기에 등록 됩니다.
		# Nginx 자신의 IP는 $server_addr에 저장 됩니다.
		proxy_set_header X-Real-IP $remote_addr;

		# 클라이언트를 포함하여 지금까지 거쳐온 클라이언트 및 프록시의 IP 주소를 콤마(,)로 구분하여 저장합니다.
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

		# 클라이언트의 요청이 어떤 프로토콜인지 알려줍니다.
		# Reverse proxy는 보통 HTTPS로 요청이 오면 이를 복호화 하고, 서버와 HTTP 통신을 합니다.
		# 이때 서버는 HTTPS로 요청이 왔다고 가정한 설정이 있을 것이기 때문에 이를 꼭 해줘야 합니다.
		proxy_set_header X-Forwarded-Proto $scheme;
	}
}